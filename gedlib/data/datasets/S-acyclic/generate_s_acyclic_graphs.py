#//////////////////////////////////////////////////////////////////////////#
#                                                                          #
#   Copyright (C) 2020 by David B. Blumenthal                              #
#                                                                          #
#   This file is part of GEDLIB.                                           #
#                                                                          #
#   GEDLIB is free software: you can redistribute it and/or modify it      #
#   under the terms of the GNU Lesser General Public License as published  #
#   by the Free Software Foundation, either version 3 of the License, or   #
#   (at your option) any later version.                                    #
#                                                                          #
#   GEDLIB is distributed in the hope that it will be useful,              #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of         #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           #
#   GNU Lesser General Public License for more details.                    #
#                                                                          #
#   You should have received a copy of the GNU Lesser General Public       #
#   License along with GEDLIB. If not, see <http://www.gnu.org/licenses/>. #
#                                                                          #
#//////////////////////////////////////////////////////////////////////////#

##
# @file generate_molecules.py
# @brief Python script for generating synthetic molecules.
# @details The synthetic molecules generated by this script were used for the experiments in the following paper:
# - D. B. Blumenthal, S. Bougleux, N. Boria, J. Gamper, L. Brun:
#   &ldquo;Comparing heuristics for graph edit distance computation&rdquo;,
#   Accepted for publication in VLDB J. 
# 
# Usage: 
# ```sh
# $ python generate molecules.py
# ```
#
# @warning Running this script overrides the molecules distributed with GEDLIB that were used for the experiments in the VLDB J. paper.
'''
Python script for generating synthetic graphs with the topology of AIDS graphs but fewer node labels.
'''

import random
import xml.etree.ElementTree as ET
import argparse
import os.path
import subprocess

node_labels = set()

class Graph:
    
    def __init__(self, dir, filename):
        # Initialize member variables.
        self.filename = filename
        self.nodes = []
        self.edges = []
        
        # Parse the nodes.
        node_id = 0
        graph = ET.parse(os.path.join(dir, filename)).getroot()
        str_to_id = {}
        global node_labels
        for node in graph.findall("graph/node"):
            str_to_id[node.attrib["id"]] = node_id
            node_label = ""
            for attr in node.findall("attr"):
                if attr.get("name") == "chem":
                    node_label = attr.find("int").text
                    break
            if node_label == "":
                raise Exception("node " + str(node_id) + " does not have attribute chem.")
            self.nodes.append((node_id, node_label))
            node_labels.add(node_label)
            node_id += 1
        
        # Parse the edges.
        adj_matrix = [[0 for col in range(len(self.nodes))] for row in range(len(self.nodes))]
        for edge in graph.findall("graph/edge"):
            tail = str_to_id[edge.attrib["from"]]
            head = str_to_id[edge.attrib["to"]]
            if adj_matrix[tail][head] == 1:
                continue
            adj_matrix[tail][head] = 1
            adj_matrix[head][tail] = 1
            self.edges.append((tail, head, edge.find("attr/int").text))
        
        
    def generate_node_labels(self, num_node_labels):
        for node in range(len(self.nodes)):
            self.nodes[node] = (self.nodes[node][0], random.randint(1, num_node_labels))
            
    def to_gxl(self, directory):
        gxl_file_name = os.path.join(directory, self.filename)
        gxl_file = open(gxl_file_name, "w")
        gxl_file.write("<?xml version=\"1.0\"?>\n")
        gxl_file.write("<!DOCTYPE gxl SYSTEM \"http://www.gupro.de/GXL/gxl-1.0.dtd\">\n")
        gxl_file.write("<gxl>\n")
        gxl_file.write("<graph id=\"" + self.filename + "\" edgeids=\"false\" edgemode=\"undirected\">\n")
        for id, label in self.nodes:
            gxl_file.write("<node id=\"_" + str(id) + "\">\n")
            gxl_file.write("<attr name=\"chem\"><int>" + str(label) + "</int></attr>\n")
            gxl_file.write("</node>\n")
        for edge in self.edges:
            gxl_file.write("<edge from=\"_" + str(edge[0]) + "\" to=\"_" + str(edge[1]) + "\">\n")
            gxl_file.write("<attr name=\"valence\"><int>" + str(edge[2]) + "</int></attr>\n")
            gxl_file.write("</edge>\n")
        gxl_file.write("</graph>\n")
        gxl_file.write("</gxl>\n")
        gxl_file.close()
        

collection = ET.parse("../../collections/acyclic.xml").getroot()
graphs = [Graph("../acyclic/", entry.attrib["file"]) for entry in collection]
print("The collection contains {} node labels".format(len(node_labels)))
for size in [3, 5, 7, 9]:
    subdir = "NL0{}".format(size)
    subprocess.call("mkdir -p " + subdir, shell=True)
    for graph in graphs:
        graph.to_gxl(subdir)
        graph.generate_node_labels(size + 2)